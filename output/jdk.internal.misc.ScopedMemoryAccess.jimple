public class jdk.internal.misc.ScopedMemoryAccess extends java.lang.Object
{
    private static final jdk.internal.misc.Unsafe UNSAFE;
    private static final jdk.internal.misc.ScopedMemoryAccess theScopedMemoryAccess;

    private static native void registerNatives();

    public boolean closeScope(jdk.internal.misc.ScopedMemoryAccess$Scope)
    {
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack2;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        boolean $stack3;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        $stack2 = <jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError: jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError INSTANCE>;

        $stack3 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean closeScope0(jdk.internal.misc.ScopedMemoryAccess$Scope,jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError)>(scope, $stack2);

        return $stack3;
    }

    native boolean closeScope0(jdk.internal.misc.ScopedMemoryAccess$Scope, jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError);

    private void <init>()
    {
        jdk.internal.misc.ScopedMemoryAccess this;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        specialinvoke this.<java.lang.Object: void <init>()>();

        return;
    }

    public static jdk.internal.misc.ScopedMemoryAccess getScopedMemoryAccess()
    {
        jdk.internal.misc.ScopedMemoryAccess $stack0;

        $stack0 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.ScopedMemoryAccess theScopedMemoryAccess>;

        return $stack0;
    }

    public void copyMemory(jdk.internal.misc.ScopedMemoryAccess$Scope, jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope srcScope, dstScope;
        long srcOffset, destOffset, bytes;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack12;
        java.lang.Object srcBase, destBase;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        srcScope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        dstScope := @parameter1: jdk.internal.misc.ScopedMemoryAccess$Scope;

        srcBase := @parameter2: java.lang.Object;

        srcOffset := @parameter3: long;

        destBase := @parameter4: java.lang.Object;

        destOffset := @parameter5: long;

        bytes := @parameter6: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void copyMemoryInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,java.lang.Object,long,long)>(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes);

     label2:
        goto label4;

     label3:
        $stack12 := @caughtexception;

        $stack13 = new java.lang.IllegalStateException;

        specialinvoke $stack13.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack13;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void copyMemoryInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack12;
        java.lang.Throwable $stack21;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope srcScope, dstScope;
        long srcOffset, destOffset, bytes;
        java.lang.Object srcBase, destBase;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        srcScope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        dstScope := @parameter1: jdk.internal.misc.ScopedMemoryAccess$Scope;

        srcBase := @parameter2: java.lang.Object;

        srcOffset := @parameter3: long;

        destBase := @parameter4: java.lang.Object;

        destOffset := @parameter5: long;

        bytes := @parameter6: long;

     label1:
        if srcScope == null goto label2;

        interfaceinvoke srcScope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        if dstScope == null goto label3;

        interfaceinvoke dstScope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label3:
        $stack12 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack12.<jdk.internal.misc.Unsafe: void copyMemory(java.lang.Object,long,java.lang.Object,long,long)>(srcBase, srcOffset, destBase, destOffset, bytes);

     label4:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(srcScope);

        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(dstScope);

        goto label7;

     label5:
        $stack21 := @caughtexception;

     label6:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(srcScope);

        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(dstScope);

        throw $stack21;

     label7:
        return;

        catch java.lang.Throwable from label1 to label4 with label5;
        catch java.lang.Throwable from label5 to label6 with label5;
    }

    public void copySwapMemory(jdk.internal.misc.ScopedMemoryAccess$Scope, jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope srcScope, dstScope;
        long srcOffset, destOffset, bytes, elemSize;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack14;
        java.lang.Object srcBase, destBase;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        srcScope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        dstScope := @parameter1: jdk.internal.misc.ScopedMemoryAccess$Scope;

        srcBase := @parameter2: java.lang.Object;

        srcOffset := @parameter3: long;

        destBase := @parameter4: java.lang.Object;

        destOffset := @parameter5: long;

        bytes := @parameter6: long;

        elemSize := @parameter7: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void copySwapMemoryInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,java.lang.Object,long,long,long)>(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);

     label2:
        goto label4;

     label3:
        $stack14 := @caughtexception;

        $stack15 = new java.lang.IllegalStateException;

        specialinvoke $stack15.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack15;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void copySwapMemoryInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack14;
        java.lang.Throwable $stack24;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope srcScope, dstScope;
        long srcOffset, destOffset, bytes, elemSize;
        java.lang.Object srcBase, destBase;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        srcScope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        dstScope := @parameter1: jdk.internal.misc.ScopedMemoryAccess$Scope;

        srcBase := @parameter2: java.lang.Object;

        srcOffset := @parameter3: long;

        destBase := @parameter4: java.lang.Object;

        destOffset := @parameter5: long;

        bytes := @parameter6: long;

        elemSize := @parameter7: long;

     label1:
        if srcScope == null goto label2;

        interfaceinvoke srcScope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        if dstScope == null goto label3;

        interfaceinvoke dstScope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label3:
        $stack14 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack14.<jdk.internal.misc.Unsafe: void copySwapMemory(java.lang.Object,long,java.lang.Object,long,long,long)>(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);

     label4:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(srcScope);

        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(dstScope);

        goto label7;

     label5:
        $stack24 := @caughtexception;

     label6:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(srcScope);

        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(dstScope);

        throw $stack24;

     label7:
        return;

        catch java.lang.Throwable from label1 to label4 with label5;
        catch java.lang.Throwable from label5 to label6 with label5;
    }

    public void setMemory(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, byte)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, bytes;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        byte value;
        java.lang.Object o;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        o := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        bytes := @parameter3: long;

        value := @parameter4: byte;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void setMemoryInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,byte)>(scope, o, offset, bytes, value);

     label2:
        goto label4;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void setMemoryInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, byte)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, bytes;
        byte value;
        java.lang.Object o;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        o := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        bytes := @parameter3: long;

        value := @parameter4: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack9.<jdk.internal.misc.Unsafe: void setMemory(java.lang.Object,long,long,byte)>(o, offset, bytes, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int vectorizedMismatch(jdk.internal.misc.ScopedMemoryAccess$Scope, jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope aScope, bScope;
        long aOffset, bOffset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack13;
        int length, log2ArrayIndexScale, $stack12;
        java.lang.Object a, b;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        aScope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        bScope := @parameter1: jdk.internal.misc.ScopedMemoryAccess$Scope;

        a := @parameter2: java.lang.Object;

        aOffset := @parameter3: long;

        b := @parameter4: java.lang.Object;

        bOffset := @parameter5: long;

        length := @parameter6: int;

        log2ArrayIndexScale := @parameter7: int;

     label1:
        $stack12 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int vectorizedMismatchInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,java.lang.Object,long,int,int)>(aScope, bScope, a, aOffset, b, bOffset, length, log2ArrayIndexScale);

     label2:
        return $stack12;

     label3:
        $stack13 := @caughtexception;

        $stack14 = new java.lang.IllegalStateException;

        specialinvoke $stack14.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack14;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int vectorizedMismatchInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, java.lang.Object, long, int, int)
    {
        java.lang.Throwable $stack24;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope aScope, bScope;
        long aOffset, bOffset;
        int length, log2ArrayIndexScale, $stack13;
        java.lang.Object a, b;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        aScope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        bScope := @parameter1: jdk.internal.misc.ScopedMemoryAccess$Scope;

        a := @parameter2: java.lang.Object;

        aOffset := @parameter3: long;

        b := @parameter4: java.lang.Object;

        bOffset := @parameter5: long;

        length := @parameter6: int;

        log2ArrayIndexScale := @parameter7: int;

     label1:
        if aScope == null goto label2;

        interfaceinvoke aScope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        if bScope == null goto label3;

        interfaceinvoke bScope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label3:
        $stack13 = staticinvoke <jdk.internal.util.ArraysSupport: int vectorizedMismatch(java.lang.Object,long,java.lang.Object,long,int,int)>(a, aOffset, b, bOffset, length, log2ArrayIndexScale);

     label4:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(aScope);

        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(bScope);

        return $stack13;

     label5:
        $stack24 := @caughtexception;

     label6:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(aScope);

        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(bScope);

        throw $stack24;

        catch java.lang.Throwable from label1 to label4 with label5;
        catch java.lang.Throwable from label5 to label6 with label5;
    }

    public boolean isLoaded(jdk.internal.misc.ScopedMemoryAccess$Scope, long, boolean, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, size;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        boolean isSync, $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        address := @parameter1: long;

        isSync := @parameter2: boolean;

        size := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean isLoadedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,long,boolean,long)>(scope, address, isSync, size);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    public boolean isLoadedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, long, boolean, long)
    {
        java.lang.Throwable $stack16;
        jdk.internal.access.JavaNioAccess $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, size;
        boolean isSync, $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        address := @parameter1: long;

        isSync := @parameter2: boolean;

        size := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = staticinvoke <jdk.internal.access.SharedSecrets: jdk.internal.access.JavaNioAccess getJavaNioAccess()>();

        $stack10 = interfaceinvoke $stack9.<jdk.internal.access.JavaNioAccess: boolean isLoaded(long,boolean,long)>(address, isSync, size);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack16 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack16;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void load(jdk.internal.misc.ScopedMemoryAccess$Scope, long, boolean, long)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, size;
        boolean isSync;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        address := @parameter1: long;

        isSync := @parameter2: boolean;

        size := @parameter3: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void loadInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,long,boolean,long)>(scope, address, isSync, size);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    public void loadInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, long, boolean, long)
    {
        java.lang.Throwable $stack13;
        jdk.internal.access.JavaNioAccess $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, size;
        boolean isSync;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        address := @parameter1: long;

        isSync := @parameter2: boolean;

        size := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = staticinvoke <jdk.internal.access.SharedSecrets: jdk.internal.access.JavaNioAccess getJavaNioAccess()>();

        interfaceinvoke $stack8.<jdk.internal.access.JavaNioAccess: void load(long,boolean,long)>(address, isSync, size);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void unload(jdk.internal.misc.ScopedMemoryAccess$Scope, long, boolean, long)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, size;
        boolean isSync;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        address := @parameter1: long;

        isSync := @parameter2: boolean;

        size := @parameter3: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void unloadInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,long,boolean,long)>(scope, address, isSync, size);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    public void unloadInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, long, boolean, long)
    {
        java.lang.Throwable $stack13;
        jdk.internal.access.JavaNioAccess $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, size;
        boolean isSync;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        address := @parameter1: long;

        isSync := @parameter2: boolean;

        size := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = staticinvoke <jdk.internal.access.SharedSecrets: jdk.internal.access.JavaNioAccess getJavaNioAccess()>();

        interfaceinvoke $stack8.<jdk.internal.access.JavaNioAccess: void unload(long,boolean,long)>(address, isSync, size);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void force(jdk.internal.misc.ScopedMemoryAccess$Scope, java.io.FileDescriptor, long, boolean, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, index, length;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.io.FileDescriptor fd;
        boolean isSync;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        fd := @parameter1: java.io.FileDescriptor;

        address := @parameter2: long;

        isSync := @parameter3: boolean;

        index := @parameter4: long;

        length := @parameter5: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void forceInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.io.FileDescriptor,long,boolean,long,long)>(scope, fd, address, isSync, index, length);

     label2:
        goto label4;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    public void forceInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.io.FileDescriptor, long, boolean, long, long)
    {
        java.lang.Throwable $stack18;
        jdk.internal.access.JavaNioAccess $stack11;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long address, index, length;
        java.io.FileDescriptor fd;
        boolean isSync;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        fd := @parameter1: java.io.FileDescriptor;

        address := @parameter2: long;

        isSync := @parameter3: boolean;

        index := @parameter4: long;

        length := @parameter5: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = staticinvoke <jdk.internal.access.SharedSecrets: jdk.internal.access.JavaNioAccess getJavaNioAccess()>();

        interfaceinvoke $stack11.<jdk.internal.access.JavaNioAccess: void force(java.io.FileDescriptor,long,boolean,long,long)>(fd, address, isSync, index, length);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack18 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack18;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public static jdk.internal.vm.vector.VectorSupport$Vector loadFromByteBuffer(java.lang.Class, java.lang.Class, int, java.nio.ByteBuffer, int, jdk.internal.vm.vector.VectorSupport$VectorSpecies, jdk.internal.vm.vector.VectorSupport$LoadOperation)
    {
        java.lang.IllegalStateException $stack11;
        jdk.internal.misc.ScopedMemoryAccess$Scope $stack8;
        jdk.internal.vm.vector.VectorSupport$LoadOperation defaultImpl;
        java.nio.ByteBuffer bb;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack10;
        int length, offset;
        java.lang.Class vmClass, e;
        jdk.internal.vm.vector.VectorSupport$Vector $stack9;
        jdk.internal.vm.vector.VectorSupport$VectorSpecies s;

        vmClass := @parameter0: java.lang.Class;

        e := @parameter1: java.lang.Class;

        length := @parameter2: int;

        bb := @parameter3: java.nio.ByteBuffer;

        offset := @parameter4: int;

        s := @parameter5: jdk.internal.vm.vector.VectorSupport$VectorSpecies;

        defaultImpl := @parameter6: jdk.internal.vm.vector.VectorSupport$LoadOperation;

     label1:
        $stack8 = staticinvoke <jdk.internal.misc.ScopedMemoryAccess$BufferAccess: jdk.internal.misc.ScopedMemoryAccess$Scope scope(java.nio.ByteBuffer)>(bb);

        $stack9 = staticinvoke <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.vm.vector.VectorSupport$Vector loadFromByteBufferScoped(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Class,java.lang.Class,int,java.nio.ByteBuffer,int,jdk.internal.vm.vector.VectorSupport$VectorSpecies,jdk.internal.vm.vector.VectorSupport$LoadOperation)>($stack8, vmClass, e, length, bb, offset, s, defaultImpl);

     label2:
        return $stack9;

     label3:
        $stack10 := @caughtexception;

        $stack11 = new java.lang.IllegalStateException;

        specialinvoke $stack11.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack11;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private static jdk.internal.vm.vector.VectorSupport$Vector loadFromByteBufferScoped(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Class, java.lang.Class, int, java.nio.ByteBuffer, int, jdk.internal.vm.vector.VectorSupport$VectorSpecies, jdk.internal.vm.vector.VectorSupport$LoadOperation)
    {
        java.lang.Throwable $stack27;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long $stack11, $stack12;
        jdk.internal.vm.vector.VectorSupport$LoadOperation defaultImpl;
        java.nio.ByteBuffer bb;
        int length, offset;
        java.lang.Class vmClass, e;
        java.lang.Object $stack10, $stack13;
        jdk.internal.vm.vector.VectorSupport$Vector $stack24;
        jdk.internal.vm.vector.VectorSupport$VectorSpecies s;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        vmClass := @parameter1: java.lang.Class;

        e := @parameter2: java.lang.Class;

        length := @parameter3: int;

        bb := @parameter4: java.nio.ByteBuffer;

        offset := @parameter5: int;

        s := @parameter6: jdk.internal.vm.vector.VectorSupport$VectorSpecies;

        defaultImpl := @parameter7: jdk.internal.vm.vector.VectorSupport$LoadOperation;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = staticinvoke <jdk.internal.misc.ScopedMemoryAccess$BufferAccess: java.lang.Object bufferBase(java.nio.ByteBuffer)>(bb);

        $stack11 = (long) offset;

        $stack12 = staticinvoke <jdk.internal.misc.ScopedMemoryAccess$BufferAccess: long bufferAddress(java.nio.ByteBuffer,long)>(bb, $stack11);

        $stack13 = staticinvoke <jdk.internal.vm.vector.VectorSupport: java.lang.Object load(java.lang.Class,java.lang.Class,int,java.lang.Object,long,java.lang.Object,int,jdk.internal.vm.vector.VectorSupport$VectorSpecies,jdk.internal.vm.vector.VectorSupport$LoadOperation)>(vmClass, e, length, $stack10, $stack12, bb, offset, s, defaultImpl);

        $stack24 = (jdk.internal.vm.vector.VectorSupport$Vector) $stack13;

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack24;

     label4:
        $stack27 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack27;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public static void storeIntoByteBuffer(java.lang.Class, java.lang.Class, int, jdk.internal.vm.vector.VectorSupport$Vector, java.nio.ByteBuffer, int, jdk.internal.vm.vector.VectorSupport$StoreVectorOperation)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess$Scope $stack8;
        jdk.internal.vm.vector.VectorSupport$StoreVectorOperation defaultImpl;
        java.nio.ByteBuffer bb;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int length, offset;
        java.lang.Class vmClass, e;
        jdk.internal.vm.vector.VectorSupport$Vector v;

        vmClass := @parameter0: java.lang.Class;

        e := @parameter1: java.lang.Class;

        length := @parameter2: int;

        v := @parameter3: jdk.internal.vm.vector.VectorSupport$Vector;

        bb := @parameter4: java.nio.ByteBuffer;

        offset := @parameter5: int;

        defaultImpl := @parameter6: jdk.internal.vm.vector.VectorSupport$StoreVectorOperation;

     label1:
        $stack8 = staticinvoke <jdk.internal.misc.ScopedMemoryAccess$BufferAccess: jdk.internal.misc.ScopedMemoryAccess$Scope scope(java.nio.ByteBuffer)>(bb);

        staticinvoke <jdk.internal.misc.ScopedMemoryAccess: void storeIntoByteBufferScoped(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Class,java.lang.Class,int,jdk.internal.vm.vector.VectorSupport$Vector,java.nio.ByteBuffer,int,jdk.internal.vm.vector.VectorSupport$StoreVectorOperation)>($stack8, vmClass, e, length, v, bb, offset, defaultImpl);

     label2:
        goto label4;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private static void storeIntoByteBufferScoped(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Class, java.lang.Class, int, jdk.internal.vm.vector.VectorSupport$Vector, java.nio.ByteBuffer, int, jdk.internal.vm.vector.VectorSupport$StoreVectorOperation)
    {
        java.lang.Throwable $stack23;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long $stack10, $stack11;
        jdk.internal.vm.vector.VectorSupport$StoreVectorOperation defaultImpl;
        java.nio.ByteBuffer bb;
        int length, offset;
        java.lang.Class vmClass, e;
        java.lang.Object $stack9;
        jdk.internal.vm.vector.VectorSupport$Vector v;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        vmClass := @parameter1: java.lang.Class;

        e := @parameter2: java.lang.Class;

        length := @parameter3: int;

        v := @parameter4: jdk.internal.vm.vector.VectorSupport$Vector;

        bb := @parameter5: java.nio.ByteBuffer;

        offset := @parameter6: int;

        defaultImpl := @parameter7: jdk.internal.vm.vector.VectorSupport$StoreVectorOperation;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = staticinvoke <jdk.internal.misc.ScopedMemoryAccess$BufferAccess: java.lang.Object bufferBase(java.nio.ByteBuffer)>(bb);

        $stack10 = (long) offset;

        $stack11 = staticinvoke <jdk.internal.misc.ScopedMemoryAccess$BufferAccess: long bufferAddress(java.nio.ByteBuffer,long)>(bb, $stack10);

        staticinvoke <jdk.internal.vm.vector.VectorSupport: void store(java.lang.Class,java.lang.Class,int,java.lang.Object,long,jdk.internal.vm.vector.VectorSupport$Vector,java.lang.Object,int,jdk.internal.vm.vector.VectorSupport$StoreVectorOperation)>(vmClass, e, length, $stack9, $stack11, v, bb, offset, defaultImpl);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack23 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack23;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getByte(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte $stack6;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        byte $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: byte getByte(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putByte(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putByte(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getByteVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte $stack6;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getByteVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getByteVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        byte $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: byte getByteVolatile(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putByteVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putByteVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putByteVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putByteVolatile(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getByteAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte $stack6;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        byte $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: byte getByteAcquire(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putByteRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putByteRelease(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getByteOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte $stack6;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getByteOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getByteOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        byte $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: byte getByteOpaque(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putByteOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putByteOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putByteOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        byte value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putByteOpaque(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndAddByte(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndAddByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndAddByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndAddByte(java.lang.Object,long,byte)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndAddByteAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndAddByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndAddByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndAddByteAcquire(java.lang.Object,long,byte)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndAddByteRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndAddByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndAddByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndAddByteRelease(java.lang.Object,long,byte)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseOrByte(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseOrByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseOrByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseOrByte(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseOrByteAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseOrByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseOrByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseOrByteAcquire(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseOrByteRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseOrByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseOrByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseOrByteRelease(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseAndByte(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseAndByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseAndByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseAndByte(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseAndByteAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseAndByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseAndByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseAndByteAcquire(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseAndByteRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseAndByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseAndByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseAndByteRelease(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseXorByte(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseXorByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseXorByteInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseXorByte(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseXorByteAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseXorByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseXorByteAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseXorByteAcquire(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public byte getAndBitwiseXorByteRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        byte value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: byte getAndBitwiseXorByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,byte)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private byte getAndBitwiseXorByteReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, byte)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        byte value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: byte;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: byte getAndBitwiseXorByteRelease(java.lang.Object,long,byte)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getShort(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        short $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        short $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: short getShort(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putShort(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack8;
        short value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        short value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putShort(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getShortUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getShortUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,boolean)>(scope, base, offset, be);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getShortUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short $stack9;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getShortUnaligned(java.lang.Object,long,boolean)>(base, offset, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putShortUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short, boolean)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

        be := @parameter4: boolean;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putShortUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short,boolean)>(scope, base, offset, value, be);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putShortUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short, boolean)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

        be := @parameter4: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putShortUnaligned(java.lang.Object,long,short,boolean)>(base, offset, value, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getShortVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        short $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getShortVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getShortVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        short $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: short getShortVolatile(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putShortVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack8;
        short value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putShortVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putShortVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        short value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putShortVolatile(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getShortAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        short $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        short $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: short getShortAcquire(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putShortRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack8;
        short value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        short value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putShortRelease(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getShortOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        short $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getShortOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getShortOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        short $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: short getShortOpaque(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putShortOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack8;
        short value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putShortOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putShortOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        short value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putShortOpaque(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndAddShort(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short delta, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndAddShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndAddShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndAddShort(java.lang.Object,long,short)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndAddShortAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short delta, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndAddShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndAddShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndAddShortAcquire(java.lang.Object,long,short)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndAddShortRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short delta, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndAddShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndAddShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndAddShortRelease(java.lang.Object,long,short)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseOrShort(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseOrShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseOrShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseOrShort(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseOrShortAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseOrShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseOrShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseOrShortAcquire(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseOrShortRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseOrShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseOrShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseOrShortRelease(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseAndShort(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseAndShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseAndShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseAndShort(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseAndShortAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseAndShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseAndShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseAndShortAcquire(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseAndShortRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseAndShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseAndShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseAndShortRelease(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseXorShort(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseXorShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseXorShortInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseXorShort(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseXorShortAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseXorShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseXorShortAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseXorShortAcquire(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public short getAndBitwiseXorShortRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: short getAndBitwiseXorShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,short)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private short getAndBitwiseXorShortReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, short)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        short value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: short;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: short getAndBitwiseXorShortRelease(java.lang.Object,long,short)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getChar(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: char getChar(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putChar(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putChar(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getCharUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getCharUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,boolean)>(scope, base, offset, be);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getCharUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char $stack9;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getCharUnaligned(java.lang.Object,long,boolean)>(base, offset, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putCharUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char, boolean)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

        be := @parameter4: boolean;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putCharUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char,boolean)>(scope, base, offset, value, be);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putCharUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char, boolean)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

        be := @parameter4: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putCharUnaligned(java.lang.Object,long,char,boolean)>(base, offset, value, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getCharVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getCharVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getCharVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: char getCharVolatile(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putCharVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putCharVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putCharVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putCharVolatile(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getCharAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: char getCharAcquire(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putCharRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putCharRelease(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getCharOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getCharOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getCharOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: char getCharOpaque(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putCharOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putCharOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putCharOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        char value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putCharOpaque(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndAddChar(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char delta, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndAddCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndAddCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndAddChar(java.lang.Object,long,char)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndAddCharAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char delta, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndAddCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndAddCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndAddCharAcquire(java.lang.Object,long,char)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndAddCharRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char delta, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndAddCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndAddCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndAddCharRelease(java.lang.Object,long,char)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseOrChar(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseOrCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseOrCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseOrChar(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseOrCharAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseOrCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseOrCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseOrCharAcquire(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseOrCharRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseOrCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseOrCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseOrCharRelease(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseAndChar(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseAndCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseAndCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseAndChar(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseAndCharAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseAndCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseAndCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseAndCharAcquire(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseAndCharRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseAndCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseAndCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseAndCharRelease(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseXorChar(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseXorCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseXorCharInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseXorChar(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseXorCharAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseXorCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseXorCharAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseXorCharAcquire(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public char getAndBitwiseXorCharRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: char getAndBitwiseXorCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,char)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private char getAndBitwiseXorCharReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, char)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        char value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: char;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: char getAndBitwiseXorCharRelease(java.lang.Object,long,char)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        int $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: int getInt(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int value;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        int value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putInt(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getIntUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int $stack7;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getIntUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,boolean)>(scope, base, offset, be);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getIntUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int $stack9;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getIntUnaligned(java.lang.Object,long,boolean)>(base, offset, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putIntUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, boolean)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

        be := @parameter4: boolean;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putIntUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,boolean)>(scope, base, offset, value, be);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putIntUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, boolean)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

        be := @parameter4: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putIntUnaligned(java.lang.Object,long,int,boolean)>(base, offset, value, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getIntVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getIntVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getIntVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        int $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: int getIntVolatile(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putIntVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int value;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putIntVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putIntVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        int value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putIntVolatile(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        int $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: int getIntAcquire(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int value;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        int value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putIntRelease(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getIntOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int $stack6;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getIntOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getIntOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        int $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: int getIntOpaque(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putIntOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        int value;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putIntOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putIntOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        int value;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putIntOpaque(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean compareAndSetInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean compareAndSetIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean compareAndSetIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean compareAndSetInt(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int compareAndExchangeInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value, $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int compareAndExchangeIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int compareAndExchangeIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value, $stack10;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: int compareAndExchangeInt(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int compareAndExchangeIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value, $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int compareAndExchangeIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int compareAndExchangeIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value, $stack10;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: int compareAndExchangeIntAcquire(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int compareAndExchangeIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value, $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int compareAndExchangeIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int compareAndExchangeIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value, $stack10;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: int compareAndExchangeIntRelease(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetIntPlain(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetIntPlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetIntPlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetIntPlain(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetInt(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetIntAcquire(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        int expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int,int)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int, int)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: int;

        value := @parameter4: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetIntRelease(java.lang.Object,long,int,int)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndSetInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndSetIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndSetIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndSetInt(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndSetIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndSetIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndSetIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndSetIntAcquire(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndSetIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndSetIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndSetIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndSetIntRelease(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndAddInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndAddIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndAddIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndAddInt(java.lang.Object,long,int)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndAddIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndAddIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndAddIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndAddIntAcquire(java.lang.Object,long,int)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndAddIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndAddIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndAddIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndAddIntRelease(java.lang.Object,long,int)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseOrInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseOrIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseOrIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseOrInt(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseOrIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseOrIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseOrIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseOrIntAcquire(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseOrIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseOrIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseOrIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseOrIntRelease(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseAndInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseAndIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseAndIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseAndInt(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseAndIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseAndIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseAndIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseAndIntAcquire(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseAndIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseAndIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseAndIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseAndIntRelease(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseXorInt(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseXorIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseXorIntInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseXorInt(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseXorIntAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseXorIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseXorIntAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseXorIntAcquire(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public int getAndBitwiseXorIntRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        int value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: int getAndBitwiseXorIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,int)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private int getAndBitwiseXorIntReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, int)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        int value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: int;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: int getAndBitwiseXorIntRelease(java.lang.Object,long,int)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: long getLong(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putLong(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getLongUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, $stack7;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getLongUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,boolean)>(scope, base, offset, be);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getLongUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, boolean)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack16;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, $stack10;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        be := @parameter3: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: long getLongUnaligned(java.lang.Object,long,boolean)>(base, offset, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack16 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack16;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putLongUnaligned(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, boolean)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

        be := @parameter4: boolean;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putLongUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,boolean)>(scope, base, offset, value, be);

     label2:
        goto label4;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putLongUnalignedInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, boolean)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value;
        java.lang.Object base;
        boolean be;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

        be := @parameter4: boolean;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack9.<jdk.internal.misc.Unsafe: void putLongUnaligned(java.lang.Object,long,long,boolean)>(base, offset, value, be);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getLongVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getLongVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getLongVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: long getLongVolatile(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putLongVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putLongVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putLongVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putLongVolatile(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: long getLongAcquire(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putLongRelease(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getLongOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getLongOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getLongOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: long getLongOpaque(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putLongOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putLongOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putLongOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset, value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putLongOpaque(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean compareAndSetLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean compareAndSetLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean compareAndSetLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        java.lang.Object base;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean compareAndSetLong(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long compareAndExchangeLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value, $stack10;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long compareAndExchangeLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long compareAndExchangeLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack12;
        java.lang.Throwable $stack20;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value, $stack13;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack12 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack13 = virtualinvoke $stack12.<jdk.internal.misc.Unsafe: long compareAndExchangeLong(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack13;

     label4:
        $stack20 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack20;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long compareAndExchangeLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value, $stack10;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long compareAndExchangeLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long compareAndExchangeLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack12;
        java.lang.Throwable $stack20;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value, $stack13;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack12 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack13 = virtualinvoke $stack12.<jdk.internal.misc.Unsafe: long compareAndExchangeLongAcquire(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack13;

     label4:
        $stack20 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack20;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long compareAndExchangeLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value, $stack10;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long compareAndExchangeLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long compareAndExchangeLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack12;
        java.lang.Throwable $stack20;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value, $stack13;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack12 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack13 = virtualinvoke $stack12.<jdk.internal.misc.Unsafe: long compareAndExchangeLongRelease(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack13;

     label4:
        $stack20 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack20;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetLongPlain(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetLongPlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetLongPlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        java.lang.Object base;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetLongPlain(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        java.lang.Object base;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetLong(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        java.lang.Object base;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetLongAcquire(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long,long)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long, long)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, expected, value;
        java.lang.Object base;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: long;

        value := @parameter4: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetLongRelease(java.lang.Object,long,long,long)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndSetLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndSetLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndSetLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndSetLong(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndSetLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndSetLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndSetLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndSetLongAcquire(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndSetLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndSetLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndSetLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndSetLongRelease(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndAddLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, delta, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndAddLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, delta);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndAddLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, delta, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndAddLong(java.lang.Object,long,long)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndAddLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, delta, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndAddLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, delta);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndAddLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, delta, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndAddLongAcquire(java.lang.Object,long,long)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndAddLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, delta, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndAddLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, delta);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndAddLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, delta, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndAddLongRelease(java.lang.Object,long,long)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseOrLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseOrLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseOrLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseOrLong(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseOrLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseOrLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseOrLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseOrLongAcquire(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseOrLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseOrLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseOrLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseOrLongRelease(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseAndLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseAndLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseAndLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseAndLong(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseAndLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseAndLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseAndLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseAndLongAcquire(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseAndLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseAndLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseAndLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseAndLongRelease(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseXorLong(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseXorLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseXorLongInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseXorLong(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseXorLongAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseXorLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseXorLongAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseXorLongAcquire(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public long getAndBitwiseXorLongRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: long getAndBitwiseXorLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,long)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private long getAndBitwiseXorLongReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, long)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset, value, $stack11;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: long getAndBitwiseXorLongRelease(java.lang.Object,long,long)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getFloat(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack6;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack8;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: float getFloat(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putFloat(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putFloat(java.lang.Object,long,float)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getFloatVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack6;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getFloatVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getFloatVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack8;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: float getFloatVolatile(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putFloatVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putFloatVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putFloatVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putFloatVolatile(java.lang.Object,long,float)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getFloatAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack6;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack8;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: float getFloatAcquire(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putFloatRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putFloatRelease(java.lang.Object,long,float)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getFloatOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack6;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getFloatOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getFloatOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float $stack8;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack8 = virtualinvoke $stack7.<jdk.internal.misc.Unsafe: float getFloatOpaque(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack8;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putFloatOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putFloatOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putFloatOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack7;
        java.lang.Throwable $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        float value;
        java.lang.Object base;
        long offset;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack7 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack7.<jdk.internal.misc.Unsafe: void putFloatOpaque(java.lang.Object,long,float)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack12 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack12;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean compareAndSetFloat(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean compareAndSetFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean compareAndSetFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean compareAndSetFloat(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float compareAndExchangeFloat(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value, $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float compareAndExchangeFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float compareAndExchangeFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value, $stack10;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: float compareAndExchangeFloat(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float compareAndExchangeFloatAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value, $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float compareAndExchangeFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float compareAndExchangeFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value, $stack10;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: float compareAndExchangeFloatAcquire(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float compareAndExchangeFloatRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value, $stack8;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float compareAndExchangeFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float compareAndExchangeFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value, $stack10;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: float compareAndExchangeFloatRelease(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetFloatPlain(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetFloatPlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetFloatPlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetFloatPlain(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetFloat(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetFloat(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetFloatAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetFloatAcquire(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetFloatRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        float expected, value;
        java.lang.Object base;
        boolean $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float,float)>(scope, base, offset, expected, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float, float)
    {
        jdk.internal.misc.Unsafe $stack9;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float expected, value;
        java.lang.Object base;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: float;

        value := @parameter4: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack9 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack10 = virtualinvoke $stack9.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetFloatRelease(java.lang.Object,long,float,float)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack10;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getAndSetFloat(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        float value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getAndSetFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getAndSetFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: float getAndSetFloat(java.lang.Object,long,float)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getAndSetFloatAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        float value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getAndSetFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getAndSetFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: float getAndSetFloatAcquire(java.lang.Object,long,float)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getAndSetFloatRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        float value, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getAndSetFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, value);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getAndSetFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float value, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: float getAndSetFloatRelease(java.lang.Object,long,float)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getAndAddFloat(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        float delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: float;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getAndAddFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getAndAddFloatInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: float getAndAddFloat(java.lang.Object,long,float)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getAndAddFloatAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        float delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: float;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getAndAddFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getAndAddFloatAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: float getAndAddFloatAcquire(java.lang.Object,long,float)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public float getAndAddFloatRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        float delta, $stack7;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: float;

     label1:
        $stack7 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: float getAndAddFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,float)>(scope, base, offset, delta);

     label2:
        return $stack7;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private float getAndAddFloatReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, float)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack15;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        float delta, $stack9;
        java.lang.Object base;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: float;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: float getAndAddFloatRelease(java.lang.Object,long,float)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack15 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack15;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getDouble(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: double getDouble(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putDouble(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putDouble(java.lang.Object,long,double)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getDoubleVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getDoubleVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getDoubleVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: double getDoubleVolatile(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putDoubleVolatile(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putDoubleVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putDoubleVolatileInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putDoubleVolatile(java.lang.Object,long,double)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getDoubleAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: double getDoubleAcquire(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putDoubleRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putDoubleRelease(java.lang.Object,long,double)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getDoubleOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        java.lang.IllegalStateException $stack8;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack7;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack6;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        $stack6 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getDoubleOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long)>(scope, base, offset);

     label2:
        return $stack6;

     label3:
        $stack7 := @caughtexception;

        $stack8 = new java.lang.IllegalStateException;

        specialinvoke $stack8.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack8;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getDoubleOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack14;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double $stack9;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack9 = virtualinvoke $stack8.<jdk.internal.misc.Unsafe: double getDoubleOpaque(java.lang.Object,long)>(base, offset);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack9;

     label4:
        $stack14 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack14;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public void putDoubleOpaque(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack9;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack8;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: void putDoubleOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, value);

     label2:
        goto label4;

     label3:
        $stack8 := @caughtexception;

        $stack9 = new java.lang.IllegalStateException;

        specialinvoke $stack9.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack9;

     label4:
        return;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private void putDoubleOpaqueInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack8;
        java.lang.Throwable $stack13;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        java.lang.Object base;
        long offset;
        double value;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack8 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        virtualinvoke $stack8.<jdk.internal.misc.Unsafe: void putDoubleOpaque(java.lang.Object,long,double)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        goto label6;

     label4:
        $stack13 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack13;

     label6:
        return;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean compareAndSetDouble(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean compareAndSetDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean compareAndSetDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean compareAndSetDouble(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double compareAndExchangeDouble(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value, $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double compareAndExchangeDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double compareAndExchangeDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack12;
        java.lang.Throwable $stack20;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value, $stack13;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack12 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack13 = virtualinvoke $stack12.<jdk.internal.misc.Unsafe: double compareAndExchangeDouble(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack13;

     label4:
        $stack20 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack20;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double compareAndExchangeDoubleAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value, $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double compareAndExchangeDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double compareAndExchangeDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack12;
        java.lang.Throwable $stack20;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value, $stack13;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack12 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack13 = virtualinvoke $stack12.<jdk.internal.misc.Unsafe: double compareAndExchangeDoubleAcquire(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack13;

     label4:
        $stack20 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack20;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double compareAndExchangeDoubleRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value, $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double compareAndExchangeDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double compareAndExchangeDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack12;
        java.lang.Throwable $stack20;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value, $stack13;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack12 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack13 = virtualinvoke $stack12.<jdk.internal.misc.Unsafe: double compareAndExchangeDoubleRelease(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack13;

     label4:
        $stack20 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack20;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetDoublePlain(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetDoublePlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetDoublePlainInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetDoublePlain(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetDouble(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetDouble(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetDoubleAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetDoubleAcquire(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public boolean weakCompareAndSetDoubleRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        java.lang.IllegalStateException $stack12;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack11;
        java.lang.Object base;
        double expected, value;
        boolean $stack10;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        $stack10 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: boolean weakCompareAndSetDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double,double)>(scope, base, offset, expected, value);

     label2:
        return $stack10;

     label3:
        $stack11 := @caughtexception;

        $stack12 = new java.lang.IllegalStateException;

        specialinvoke $stack12.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack12;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private boolean weakCompareAndSetDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double, double)
    {
        jdk.internal.misc.Unsafe $stack11;
        java.lang.Throwable $stack19;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double expected, value;
        boolean $stack12;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        expected := @parameter3: double;

        value := @parameter4: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack11 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack12 = virtualinvoke $stack11.<jdk.internal.misc.Unsafe: boolean weakCompareAndSetDoubleRelease(java.lang.Object,long,double,double)>(base, offset, expected, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack12;

     label4:
        $stack19 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack19;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getAndSetDouble(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;
        double value, $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getAndSetDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getAndSetDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double value, $stack11;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: double getAndSetDouble(java.lang.Object,long,double)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getAndSetDoubleAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;
        double value, $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getAndSetDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getAndSetDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double value, $stack11;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: double getAndSetDoubleAcquire(java.lang.Object,long,double)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getAndSetDoubleRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;
        double value, $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getAndSetDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, value);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getAndSetDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double value, $stack11;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        value := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: double getAndSetDoubleRelease(java.lang.Object,long,double)>(base, offset, value);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getAndAddDouble(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;
        double delta, $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: double;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getAndAddDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, delta);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getAndAddDoubleInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double delta, $stack11;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: double getAndAddDouble(java.lang.Object,long,double)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getAndAddDoubleAcquire(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;
        double delta, $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: double;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getAndAddDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, delta);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getAndAddDoubleAcquireInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double delta, $stack11;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: double getAndAddDoubleAcquire(java.lang.Object,long,double)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    public double getAndAddDoubleRelease(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        java.lang.IllegalStateException $stack10;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError $stack9;
        java.lang.Object base;
        double delta, $stack8;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: double;

     label1:
        $stack8 = virtualinvoke this.<jdk.internal.misc.ScopedMemoryAccess: double getAndAddDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope,java.lang.Object,long,double)>(scope, base, offset, delta);

     label2:
        return $stack8;

     label3:
        $stack9 := @caughtexception;

        $stack10 = new java.lang.IllegalStateException;

        specialinvoke $stack10.<java.lang.IllegalStateException: void <init>(java.lang.String)>("This segment is already closed");

        throw $stack10;

        catch jdk.internal.misc.ScopedMemoryAccess$Scope$ScopedAccessError from label1 to label2 with label3;
    }

    private double getAndAddDoubleReleaseInternal(jdk.internal.misc.ScopedMemoryAccess$Scope, java.lang.Object, long, double)
    {
        jdk.internal.misc.Unsafe $stack10;
        java.lang.Throwable $stack17;
        jdk.internal.misc.ScopedMemoryAccess this;
        jdk.internal.misc.ScopedMemoryAccess$Scope scope;
        long offset;
        java.lang.Object base;
        double delta, $stack11;

        this := @this: jdk.internal.misc.ScopedMemoryAccess;

        scope := @parameter0: jdk.internal.misc.ScopedMemoryAccess$Scope;

        base := @parameter1: java.lang.Object;

        offset := @parameter2: long;

        delta := @parameter3: double;

     label1:
        if scope == null goto label2;

        interfaceinvoke scope.<jdk.internal.misc.ScopedMemoryAccess$Scope: void checkValidState()>();

     label2:
        $stack10 = <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE>;

        $stack11 = virtualinvoke $stack10.<jdk.internal.misc.Unsafe: double getAndAddDoubleRelease(java.lang.Object,long,double)>(base, offset, delta);

     label3:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        return $stack11;

     label4:
        $stack17 := @caughtexception;

     label5:
        staticinvoke <java.lang.ref.Reference: void reachabilityFence(java.lang.Object)>(scope);

        throw $stack17;

        catch java.lang.Throwable from label1 to label3 with label4;
        catch java.lang.Throwable from label4 to label5 with label4;
    }

    static void <clinit>()
    {
        jdk.internal.misc.Unsafe $stack0;
        jdk.internal.misc.ScopedMemoryAccess $stack1;

        $stack0 = staticinvoke <jdk.internal.misc.Unsafe: jdk.internal.misc.Unsafe getUnsafe()>();

        <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.Unsafe UNSAFE> = $stack0;

        staticinvoke <jdk.internal.misc.ScopedMemoryAccess: void registerNatives()>();

        $stack1 = new jdk.internal.misc.ScopedMemoryAccess;

        specialinvoke $stack1.<jdk.internal.misc.ScopedMemoryAccess: void <init>()>();

        <jdk.internal.misc.ScopedMemoryAccess: jdk.internal.misc.ScopedMemoryAccess theScopedMemoryAccess> = $stack1;

        return;
    }
}
